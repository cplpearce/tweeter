/* your tweet html template, any changes here will echo to index.html on generation */
const tweetTemplate = (
  avatar = "/images/avatars/001-man.png",
  name = "Error",
  handle = "@error",
  tweet = "error",
  date = Date.now()
) => {
  return `
  <article class="tweet-container">
  <header>
    <img class="tweet-l" src="${escape(avatar)}">
    <span class="tweet-l">${escape(name)}</span>
    <span class="tweet-r handle">${escape(handle)}</span>
  </header>
  <main>
    ${escape(tweet)}
  </main>
  <footer>
    <span class="tweet-l">${dateDayCalc(date)}</span>
    <div class="tweet-r">
      <img class="icon" src="/images/icons/bxs-flag-alt.svg">
      <img class="icon" src="/images/icons/bx-repost.svg">
      <img class="icon" src="/images/icons/bxs-heart.svg">
    </div>
  </footer>
  </article>
  `;
};

// simple day calculator to register days since tweeting
const dateDayCalc = (date) => {
  // get the non-float result, absolute value (+), of the date tweeted minus today
  // divided by 1000 ms, 60 * 60 seconds/minutes, and 24 hours per day.
  const daysSince = Math.floor(
    Math.abs(new Date(date) - Date.now()) / (1000 * 3600 * 24)
  );
  let returnDays;
  if (daysSince > 1) {
    returnDays = `${daysSince} Days Ago`;
  } else if (daysSince === 1) {
    returnDays = `${daysSince} Day Ago`;
  } else {
    returnDays = "Today";
  }
  return returnDays;
};

// function to fix sneaky user injects
const escape = function (str) {
  let div = document.createElement("div");
  div.appendChild(document.createTextNode(str));
  return div.innerHTML;
};

// take in a data object, and parse it by key - defaults are set in case the
// input db changes its key system
const buildTweet = (
  data,
  avatarKey = data.user.avatars,
  nameKey = data.user.name,
  handleKey = data.user.handle,
  textKey = data.content.text,
  dateKey = data.created_at
) => {
  $("#tweet-feed").prepend(
    tweetTemplate(avatarKey, nameKey, handleKey, textKey, dateKey)
  );
};

// get all the tweets from /tweets and render them
const loadTweets = () => {
  // fade out $( '#tweet-feed' ) and clear it
  $("#tweet-feed").fadeTo(200, 0, () => {
    // keep $( '#tweet-feed' )'s height so the page isn't jumpy
    $("#tweet-feed").css("min-height", $("#tweet-feed").css("height"));
    // clear it now that it's hidden
    $("#tweet-feed").html("");
    // use ajax to get all our tweets
    $.ajax("/tweets", "GET")
      // then for each key, append them (so we go from newest to oldest tweet)
      .then((response) => {
        Object.keys(response).map((tweet) => buildTweet(response[tweet]));
      })
      // then, fade $( '#tweet-feed' ) back in
      .then($("#tweet-feed").fadeTo(1500, 1));
  });
};

/* on document ready, fetch the previous tweets from your source
   note, tweets are generated by "tweetTemplate" defined above. */
$(document).ready(() => {
  // submit a new tweet
  $("#new-tweet-form").submit((event) => {
    event.preventDefault();
    // check for an empty tweet
    if (!$("#tweet-text").val()) {
      toast("You can't post an empty tweet!");
    }
    // or too long of a tweet
    else if ($("#tweet-text").val().length > 140) {
      toast("Your tweet can't be over 140 characters!");
    }
    // then post the tweet via ajax
    else {
      $.post("/tweets", $("#new-tweet-form").serialize(), () => {
        // inform the user
        toast("Tweeted Successfully!", true);
        // fade out the user input (fadeTo so css:display doens't become hidden)
        $("#tweet-text").fadeTo(500, 0, () => {
          // clear the text area and hard set the counter back to 140, and call a blur event
          $("#tweet-text").val("").blur() &&
            $(".counter").html("140") &&
            $("#tweet-text").fadeTo(500, 1);
          // get *our* latest tweet
          $.get("/tweets", (res) => {
            $("#tweet-feed").prepend(buildTweet(res[res.length - 1]));
          });
        });
      });
    }
  });

  // render all the tweets to our page
  loadTweets();
});
